HEALTHCARE ANALYTICS LAB - DESIGN DECISIONS
Star Schema Design Choices
============================================

DECISION 1: FACT TABLE GRAIN
-----------------------------

CHOSEN OPTION: A - One Row Per Encounter

RATIONALE:
The fact table will have exactly one row for each encounter in the source system.
This grain was chosen because:

1. MATCHES BUSINESS PROCESS
   - An encounter is the fundamental atomic unit of healthcare delivery
   - Each encounter represents a discrete patient visit/admission
   - Natural alignment with how clinicians and analysts think about care delivery

2. OPTIMAL FOR 75% OF QUERIES
   - Query 1 (Monthly Encounters): Simple COUNT(*) - no DISTINCT needed
   - Query 3 (Readmission Rate): Clean one-to-one mapping for self-join logic
   - Query 4 (Revenue by Specialty): One encounter = one billing record, no duplication

3. CLEAN AGGREGATIONS
   - COUNT(*) for encounter counts (fast, no DISTINCT overhead)
   - SUM(total_allowed_amount) for revenue (no risk of double-counting)
   - AVG(length_of_stay) for average stay calculations

4. NO DATA DUPLICATION
   - Encounter-level facts (dates, revenue, LOS) stored exactly once
   - Minimal storage footprint compared to per-diagnosis or per-procedure grain

5. HANDLES QUERY 2 ELEGANTLY
   - Diagnosis-procedure pairs require bridge tables (industry best practice)
   - Many-to-many relationships properly normalized via bridge tables
   - Avoids row explosion that would occur with denormalized approach

REJECTED OPTIONS:
- Option B (One row per diagnosis): Would require DISTINCT for Q1, Q3, Q4; duplicates revenue
- Option C (One row per procedure): Same issues as Option B; complicates most queries

============================================

DECISION 2: DIMENSION TABLES
-----------------------------

The following dimension tables will be created:

1. DIM_DATE
   Purpose: Calendar dimension for time-based analysis
   Attributes:
   - date_key (PK, surrogate key) -- PRIMARY KEY (clustered index for joins)
   - calendar_date (actual date) -- INDEX (unique date lookups)
   - year (YYYY)
   - quarter (Q1-Q4)
   - month (1-12)
   - month_name (January-December)
   - year_month (YYYY-MM) -- INDEX (frequent GROUP BY in all queries)
   - day_of_week (1-7)
   - day_name (Monday-Sunday)
   - is_weekend (boolean)

   
   Why: Pre-computing date attributes eliminates DATE_FORMAT() calls at query time

2. DIM_PATIENT
   Purpose: Patient demographics and attributes
   Attributes:
   - patient_key (PK, surrogate key) -- PRIMARY KEY (clustered index for joins)
   - patient_id (natural key from source) -- INDEX (lookup from source system)
   - mrn (medical record number) -- INDEX (unique identifier for patient lookup)
   - first_name
   - last_name
   - full_name (concatenated)
   - date_of_birth
   - age_group (0-17, 18-34, 35-54, 55-74, 75+) -- pre-computed buckets
   - gender
   - effective_date (SCD Type 2 if tracking changes)
   - expiration_date (SCD Type 2)
   - is_current (boolean, SCD Type 2) -- INDEX (filter for current records only)
   
   Why: Pre-computed age groups enable demographic analysis without CASE statements

3. DIM_PROVIDER
   Purpose: Provider information including specialty
   Attributes:
   - provider_key (PK, surrogate key) -- PRIMARY KEY (clustered index for joins)
   - provider_id (natural key from source) -- INDEX (lookup from source system)
   - first_name
   - last_name
   - full_name (concatenated)
   - credential (MD, DO, NP, PA)
   - specialty_id (denormalized from specialties table) -- INDEX (filtering by specialty)
   - department_id (denormalized from departments table)
   - effective_date (SCD Type 2)
   - expiration_date (SCD Type 2)
   - is_current (boolean, SCD Type 2) -- INDEX (filter for current records only)
   
   Why: Denormalizing specialty into provider dimension eliminates JOIN chain

4. DIM_SPECIALTY
   Purpose: Medical specialty lookup
   Attributes:
   - specialty_key (PK, surrogate key) -- PRIMARY KEY (clustered index for joins)
   - specialty_id (natural key from source) -- INDEX (lookup from source system)
   - specialty_name (Cardiology, Internal Medicine, etc.)
   - specialty_code (CARD, IM, ER)
   - specialty_category (Medical, Surgical, Diagnostic)
   
   Why: Separate dimension allows specialty-level analysis independent of provider

5. DIM_DEPARTMENT
   Purpose: Hospital department/unit information
   Attributes:
   - department_key (PK, surrogate key) -- PRIMARY KEY (clustered index for joins)
   - department_id (natural key from source) -- INDEX (lookup from source system)
   - department_name
   - floor (physical location)
   - capacity (bed count)
   - department_type (Inpatient, Outpatient, ER, Surgical)
   
   Why: Enables location-based analysis and capacity planning

6. DIM_ENCOUNTER_TYPE
   Purpose: Type of patient encounter
   Attributes:
   - encounter_type_key (PK, surrogate key) -- PRIMARY KEY (clustered index for joins)
   - encounter_type (Outpatient, Inpatient, ER) -- INDEX (frequent filtering and GROUP BY)
   - encounter_type_category (Ambulatory, Acute, Emergency)
   - expected_los_days (average expected length of stay)
   
   Why: Small dimension (3-5 rows) but important for filtering and grouping

DESIGN PATTERN: CONFORMED DIMENSIONS
- dim_date, dim_patient, dim_provider are conformed dimensions
- Can be shared across multiple fact tables (future expansion)
- Consistent definitions ensure cross-fact analysis

============================================

DECISION 3: PRE-AGGREGATED METRICS
-----------------------------------

The following metrics will be pre-computed and stored in fact_encounters:

1. DIAGNOSIS_COUNT (INT)
   - Number of diagnoses associated with this encounter
   - Source: COUNT from encounter_diagnoses table during ETL
   - Why: Eliminates need to join to bridge table for simple counts
   - Use case: "Show encounters with 3+ diagnoses"

2. PROCEDURE_COUNT (INT)
   - Number of procedures performed during this encounter
   - Source: COUNT from encounter_procedures table during ETL
   - Why: Eliminates need to join to bridge table for simple counts
   - Use case: "Show encounters with no procedures"

3. TOTAL_CLAIM_AMOUNT (DECIMAL)
   - Total amount billed to insurance
   - Source: billing.claim_amount
   - Why: Denormalized from billing table for direct access
   - Use case: Revenue analysis without joining billing table

4. TOTAL_ALLOWED_AMOUNT (DECIMAL)
   - Total amount allowed/paid by insurance
   - Source: billing.allowed_amount
   - Why: Denormalized from billing table for direct access
   - Use case: Query 4 (Revenue by Specialty) - no billing join needed

5. LENGTH_OF_STAY_DAYS (INT)
   - Days between admission and discharge (for inpatient)
   - Source: DATEDIFF(discharge_date, encounter_date)
   - Why: Eliminates date calculation at query time
   - Use case: Average LOS analysis, outlier detection

6. IS_READMISSION (BOOLEAN)
   - Flag indicating if this is a 30-day readmission
   - Source: Calculated during ETL by checking if patient had discharge within 30 days
   - Why: ELIMINATES SELF-JOIN for Query 3 (massive performance gain)
   - Use case: Query 3 transformed from self-join to simple WHERE clause

7. HAS_BILLING (BOOLEAN)
   - Flag indicating if billing record exists
   - Source: EXISTS check on billing table during ETL
   - Why: Fast filtering without joining billing table
   - Use case: "Show unbilled encounters"

PERFORMANCE IMPACT:
- Pre-aggregation trades:
  * Storage: Additional ~40 bytes per encounter row
  * ETL complexity: More complex transformation logic
  * Query performance: 5-10x faster aggregation queries
  
JUSTIFICATION:
In a data warehouse, storage is cheap but query performance is critical.
Pre-computing these metrics once during ETL saves computing them thousands
of times during analyst queries. This follows the "compute once, read many" 
principle of dimensional modeling.

============================================

DECISION 4: BRIDGE TABLES
--------------------------

CHOSEN APPROACH: YES - We need Bridge Tables for Many-to-Many Relationships

BRIDGE TABLES TO CREATE:

1. BRIDGE_ENCOUNTER_DIAGNOSES
   Attributes:
   - encounter_key (FK to fact_encounters) -- INDEX (join to fact table)
   - diagnosis_key (FK to dim_diagnosis) -- INDEX (join to diagnosis dimension)
   - diagnosis_sequence (1=primary, 2=secondary, etc.)
   - diagnosis_date (if different from encounter date)
   - COMPOSITE INDEX (encounter_key, diagnosis_key) -- optimizes bi-directional joins
   
2. BRIDGE_ENCOUNTER_PROCEDURES
   Attributes:
   - encounter_key (FK to fact_encounters) -- INDEX (join to fact table)
   - procedure_key (FK to dim_procedure) -- INDEX (join to procedure dimension)
   - procedure_date
   - procedure_sequence (order performed)
   - COMPOSITE INDEX (encounter_key, procedure_key) -- optimizes bi-directional joins

WHY USE BRIDGE TABLES?

1. CORRECT MODELING OF MANY-TO-MANY
   - One encounter can have multiple diagnoses (average: 2-3)
   - One encounter can have multiple procedures (average: 1-2)
   - Many-to-many requires junction table in any schema (OLTP or DW)

2. AVOIDS FACT TABLE BLOAT
   - Option B (per-diagnosis grain) would create 2-3x more fact rows
   - Option C (per-procedure grain) would create 1-2x more fact rows
   - Bloated fact table slows down ALL queries, even those not using diagnoses

3. QUERY FLEXIBILITY
   - Queries not using diagnoses/procedures don't pay join penalty
   - Queries needing diagnosis-procedure pairs join only when necessary
   - Clean separation of concerns

4. ACCURATE AGGREGATION
   - Fact table has one row per encounter - no DISTINCT needed for counts
   - Revenue, LOS, and other measures stored once (no duplication risk)
   - Bridge tables joined only for diagnosis/procedure-specific analysis

5. INDUSTRY BEST PRACTICE
   - Kimball methodology explicitly recommends bridge tables for many-to-many
   - Used in healthcare, retail (products-to-transactions), finance (accounts-to-customers)
   - Proven pattern for managing complex relationships in star schema

WHY NOT DENORMALIZE INTO FACT?

REJECTED APPROACH: Store all diagnoses/procedures as columns in fact table
   - fact_encounters.diagnosis_1, diagnosis_2, diagnosis_3 ... diagnosis_10?
   
Problems:
   ❌ Wastes space (most encounters have 1-2 diagnoses, not 10)
   ❌ Hard-coded limit (what if encounter has 11 diagnoses?)
   ❌ Complex queries (UNION across all diagnosis columns)
   ❌ Cannot maintain sequence information cleanly

TRADE-OFFS ACCEPTED:

Pros of Bridge Tables:
✅ Correct modeling of many-to-many relationships
✅ No fact table bloat
✅ Accurate aggregations without DISTINCT
✅ Query flexibility (join only when needed)

Cons of Bridge Tables:
⚠️ Query 2 requires additional joins to bridge tables
⚠️ More complex ETL (must populate bridge tables)
⚠️ Slightly more storage (separate tables vs. embedded)

CONCLUSION:
The benefits far outweigh the costs. Query 2 is 1 of 4 queries, and the
performance gain for Q1, Q3, Q4 (no DISTINCT, no duplication) justifies
the additional joins needed for Q2.


============================================

SUMMARY OF DESIGN CHOICES
--------------------------

Grain: One row per encounter (matches business process)
Dimensions: 6 core dimensions with denormalized attributes
Pre-aggregation: 7 key metrics computed during ETL
Bridge Tables: Yes, for diagnoses and procedures

Expected Performance Improvement:
- Query 1: 3-5x faster (no date functions, direct specialty access)
- Query 2: 2-3x faster (indexed bridge tables vs. OLTP junction tables)
- Query 3: 10-15x faster (pre-computed readmission flag, no self-join)
- Query 4: 5-7x faster (no JOIN chain, denormalized revenue)

Overall: 5-10x average improvement across all queries

============================================
